#zeopy: simple Python interface to the Zeo++ `network` tool.
# Alby Musaelian 2018

from __future__ import (absolute_import, division,
                        print_function)

import os
import tempfile
import subprocess

import ase
import ase.io

# TODO: benchmark CUC vs CIF

class Zeopy(object):
    """An instance of the `network` tool that can be repeatedly invoked.

    :warning: Do not use a single instance of Zeopy in parallel.
    """

    def __init__(self, path_to_zeo):
        """Create a Zeopy.

        :param str path_to_zeo: Path to the `network` executable.
        """
        self._exe = path_to_zeo
        self._tmpdir = tempfile.mkdtemp()

    def voronoi(self, structure, radial = False, verbose=True):
        """
        :param Atoms structure: The ASE Atoms to compute the Voronoi decomposition of.
        """

        inp = os.path.join(self._tmpdir, "in.cuc")
        outp = os.path.join(self._tmpdir, "out.nt2")

        #ase.io.write(inp, structure)

        with open(inp, "w") as inf:
            inf.write(self.ase2cuc(structure))

        args = []

        if not radial:
            args = ["-nor"]

        output = subprocess.check_output([self._exe] + args + ["-nt2", outp, inp])

        if verbose:
            print(output)

        with open(outp, "r") as outf:
            return self.parse_nt2(outf.readlines())

    @staticmethod
    def ase2cuc(at):
        """Convert an ase.Atoms to the CUC format.

        See http://www.maciejharanczyk.info/Zeopp/input.html

        :returns: A string in CUC format.
        """
        ls = ["Autogenerated"]
        c = at.get_cell_lengths_and_angles()
        ls.append("Unit_cell: {:0.16f} {:0.16f} {:0.16f} {:0.16f} {:0.16f} {:0.16f}".format(*c))
        for sym, pos in zip(at.get_chemical_symbols(), at.get_scaled_positions()):
            ls.append("{} {:0.16f} {:0.16f} {:0.16f}".format(sym, *pos))

        return "\n".join(ls)

    @staticmethod
    def parse_nt2(nt2lines):

        where = None

        vertices = []
        edges = []

        for l in nt2lines:
            if not l.strip():
                continue
            elif l.startswith("Vertex table:"):
                where = 'vertex'
            elif l.startswith("Edge table:"):
                where = 'edge'
            elif where == 'vertex':
                # Line format:
                # [node_number:int] [x] [y] [z] [radius] [region-vertex-atom-indexes]
                e = l.split()
                vertices.append({
                    'number' : int(e[0]),
                    'coords' : [float(f) for f in e[1:4]],
                    'radius' : float(e[4]),
                    'region-atom-indexes' : [int(i) for i in e[5:]]
                })
            elif where == 'edge':
                # Line format:
                # [from node] -> [to node] [radius] [delta uc x] ['' y] ['' z] [length]

                # TODO: For now, just ignore everything but from and to
                e = l.split()
                edges.append({
                    'from' : int(e[0]),
                    'to' : int(e[2])
                })
            else:
                raise RuntimeError("Huh?")

        return vertices, edges
